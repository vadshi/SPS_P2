
# Наследование может сослужить хорошую службу, когда вы хотите, чтобы класс-
# потомок большую часть времени вел себя как родительский класс (потомок является 
# родителем). Возможность создавать иерархии наследования довольно заманчива, 
# но иногда композиция или агрегирование имеет больше смысла. В чем разница?
# При композиции один объект является частью другого.
# Утка является птицей (наследование), но имеет хвост (композиция).
# Хвост не похож на утку — он является частью утки.
# В следующем примере создадим объекты bill и tail и предоставим
# их новому объекту duck:

class Bill():
    def __init__(self, description):
        self.description = description


class Tail():
    def __init__(self, length):
        self.length = length


class Duck():
    def __init__(self, bill, tail):
        self.bill = bill
        self.tail = tail
    
    def about(self):
        print(f'У утки {self.bill.description} клюв и {self.tail.length} хвост.')


tail = Tail('длинный')
bill = Bill('широкий оранжевый')
duck = Duck(bill, tail)
duck.about()

# Агрегирование выражает более свободные отношения между объектами: один из 
# них использует другой, но оба они существуют независимо друг от друга.
# Утка использует озеро, но не является его частью.